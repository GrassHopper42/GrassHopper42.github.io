{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"오삽내 오늘의 삽질 내용 서비스 백엔드를 에서 으로 넘어가면서 까지 통으로 새로배우면서 뚝딱거리려니 힘들다. 그나마 로 타입지정하고 에서 데코레이션 달아보고 와 유사한 부분도 있어서 한결 수월하다는데 위안을 삼고 있다.\n오늘은 몇시간동안 낑낑거렸는데 허무하게 끝난 Trouble Shooting이 구글링할때 나오지 않은게 아쉬워 짧게나마 삽질 내용을 남겨보…","fields":{"slug":"/spring-boot-localdatetime-error/"},"frontmatter":{"date":"July 07, 2022","title":"[오삽내]private LocalDateTime 에러 해결...","tags":["Java","Spring","Mongodb","TroubleShooting"]},"rawMarkdownBody":"\n## 오삽내\n\n> 오늘의 삽질 내용\n\n서비스 백엔드를 `NestJS`에서 `Spring`으로 넘어가면서 `Java`까지 통으로 새로배우면서 뚝딱거리려니 힘들다. 그나마 `TypeScript`로 타입지정하고 `NestJS`에서 데코레이션 달아보고 `JavaScript`와 유사한 부분도 있어서 한결 수월하다는데 위안을 삼고 있다.\n오늘은 몇시간동안 낑낑거렸는데 허무하게 끝난 Trouble Shooting이 구글링할때 나오지 않은게 아쉬워 짧게나마 삽질 내용을 남겨보려한다.  \n`Spring Data Mongodb`로 DB연결하고 간단한 CRUD코드 몇개 만들어서 테스트를 돌려보는데 전혀 예상치도 못결 부분에서 에러가 터졌다.\n`createdAt`에 `Date`타입을 적용하기 위해 선언한 `LocalDateTime`타입에서 오류가 나서 클래스가 생성되지 못하고 꺼져버리는 것이었다.\n몇시간동안 구글링을 했는데 답이나오지 않아 스택오버플로우에 질문을 올리고 혼자 깨달음을 얻어 허무하게 끝나버렸다.\n\n## 문제\n\n아래는 `LocalDateTime`타입이 사용된 `User`모델의 일부이다.\n\n```java\n// User.java\nimport java.time.LocalDateTime;\n\n@Data\n@NoArgsConstructor\n@Document(\"User\")\npublic class User {\n\n  @Id\n  private ObjectId id;\n\n  @CreatedDate\n  private LocalDateTime createdAt;\n\n  @LastModifiedDate\n  private LocalDateTime updatedAt;\n\n  private String username;\n\n  // ...\n}\n```\n\n이 상태로 테스트를 돌렸더니 아래의 에러를 볼 수 있었다.\n\n```sh\nCaused by: java.lang.reflect.InaccessibleObjectException: Unable to make private java.time.LocalDateTime(java.time.LocalDate,java.time.LocalTime) accessible: module java.base does not \"opens java.time\" to unnamed module\n```\n\n## 해결\n\n### 1. VmArgs 설정\n\n이 에러 문구를 가지고 이렇게 저렇게 조합해보면서 구글링을 하다가 한 [스택오버플로우 답변](https://stackoverflow.com/questions/70412805/what-does-this-error-mean-java-lang-reflect-inaccessibleobjectexception-unable)을 발견했다.\n\n`start-argument`로 `--add-opens java.base/java.time=ALL-UNNAMED`를 입력하라는 글이었는데, 이게 도통 뭔소리고 VSC에서 어떻게 입력해줘야 할지도 모르겠어서 넘겨버렸다.\n한참 낑낑대다가 스택오버플로우 질문을 남겼더니 위 답변의 링크를 주면서 이걸로 해결이 안되냐는 코멘트가 달렸다. 이게 진짜 되는건가 하고 VSC로 vm 설정하는 법을 찾아서 입력해봤다.\n\nVSC에서 위와 같은 args를 입력하기 위해서는 상단 **Run**탭에서 **Open Configuration | Add Configuration**을 누르거나 프로젝트 루트에서 `.vscode` 폴더에 있는 `launch.json`에 `vmArgs`을 키로 추가한 뒤 값에는 `-add-opens java.base/...`을 입력해주면 된다.\n\n```json\n{\n  // Use IntelliSense to learn about possible attributes.\n  // Hover to view descriptions of existing attributes.\n  // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387\n  \"version\": \"0.2.0\",\n  \"configurations\": [\n    {\n      \"type\": \"java\",\n      \"name\": \"Launch Current File\",\n      \"request\": \"launch\",\n      \"mainClass\": \"${file}\",\n      \"vmArgs\": \"--add-opens java.base/java.time=ALL-UNNAMED\"\n    },\n    {\n      \"type\": \"java\",\n      \"name\": \"Launch ApiApplication\",\n      \"request\": \"launch\",\n      \"mainClass\": \"art.unhide.api.ApiApplication\",\n      \"projectName\": \"api\",\n      \"vmArgs\": \"--add-opens java.base/java.time=ALL-UNNAMED\"\n    }\n  ]\n}\n```\n\n> IDE 짱짱맨... vim은 그냥 VSC 플러그인으로만 쓰는걸로...\n\n하지만 여전히 테스트에서는 같은 에러가 발생한다. 테스트에서 VmArgs를 입력하려면 `.vscode` 폴더의 `setting.json`파일에서 아래의 코드를 추가해준다.\n\n```json\n\"java.test.config\": {\n  \"vmArgs\": [\"--add-opens\", \"java.base/java.time=ALL-UNNAMED\"]\n}\n```\n\n### 2. package 변경\n\n위의 방법으로 작동시키면 정상적으로 작동하는데 로그에서 아래와 같은 경고문구를 볼 수 있었다.\n처음엔 테스트에서 별도로 VmArgs를 입력하는 방법을 몰라 이 방법을 썼었다.\n\n```sh\nWARN 17980 --- [  restartedMain] o.s.data.convert.CustomConversions       : Registering converter from class java.time.LocalDateTime to class org.joda.time.LocalDateTime as reading converter although it doesn't convert from a store-supported type; You might want to check your annotation setup at the converter implementation\n```\n\n시스템에서 `java.time.LocalDateTime`을 `org.joda.time.LocalDateTime`으로 convert 시켜같는 것 같다. 그래서 convert할 필요 없게 package를 바꿔줬다. 아래는 바뀐 코드이다.\n\n```java\n// User.java\nimport org.joda.time.LocalDateTime; // 바뀐부분\n\n@Data\n@NoArgsConstructor\n@Document(\"User\")\npublic class User {\n\n  @Id\n  private ObjectId id;\n\n  @CreatedDate\n  private LocalDateTime createdAt;\n\n  @LastModifiedDate\n  private LocalDateTime updatedAt;\n\n  private String username;\n\n  // ...\n}\n```\n\n이 방법을 쓰면 별다른 설정 없이도 문제없이 동작한다.\n\n> 그렇지만 로그는 여전히 `java.time`을 `org.joda.time`으로 convert한다... 찾아보니 사실 관련 없었던것... 그냥 뒷걸음질 치다 쥐 잡은 것 같다.\n\n## 이유\n\n는 잘 모르겠다... 구글링하다보니 `java.time` 뿐만 아니라 `java.util`같은 다른 자바 내장 패키지들도 이따금 private으로 선언하면 비슷한 에러를 띄우는것 같았다.\n유사한 문제에 대해서는 로그를 참고해 위의 VmArgs를 조금 바꿔서 추가해주면 해결될 듯 하다.  \n재밌는건 모델만 만들어 뒀을때는 문제가 발생하지 않는데 Repository와 Service, Controller를 만들어 주입시키면 문제가 생긴다.  \n`java.time`의 `ZonedDateTime`을 사용하는 경우도 있는것 같았는데 이건 자체적으로 convert가 되지 않는 것 같다.\n[이 글](https://www.baeldung.com/spring-data-mongodb-zoneddatetime)에서 `ZonedDateTime`의 Custom Converter를 만들어주는 방법을 상세하게 알려주고 있다.\nLocalDateTime과 ZonedDateTime의 차이를 비교해보고 더 유용하겠다 싶으면 적용해봐야겠다.\n\n## 참고자료\n\n- [StackOverflow](https://stackoverflow.com/questions/70412805/what-does-this-error-mean-java-lang-reflect-inaccessibleobjectexception-unable)\n- [ZonedDateTime Converter](https://www.baeldung.com/spring-data-mongodb-zoneddatetime)\n- [NaverD2](https://d2.naver.com/helloworld/645609)\n- [Spring-boot Github issue](https://github.com/spring-projects/spring-boot/issues/18817)\n"},{"excerpt":"개발을 처음 배울때부터 WSL을 세팅해서 사용했지만 VSC를 주로 사용하다보니 기본적인 세팅만 해두고 썼지만 이번에 백엔드를 Spring boot로 전환하면서 Vim을 적극적으로 이용해보기로 했다.\nVim을 이용하려고 세팅을 좀 만지다보니 또 세팅병이 도져서 터미널을 갈아엎었다고 볼 수 있을만큼 손을 많이 댔는데 이 과정에서 하루~이틀정도 삽질을 했던것같…","fields":{"slug":"/tmux-init/"},"frontmatter":{"date":"June 17, 2022","title":"Tmux Setting","tags":["tmux","vim","WSL"]},"rawMarkdownBody":"\n개발을 처음 배울때부터 WSL을 세팅해서 사용했지만 VSC를 주로 사용하다보니 기본적인 세팅만 해두고 썼지만 이번에 백엔드를 Spring boot로 전환하면서 Vim을 적극적으로 이용해보기로 했다.\nVim을 이용하려고 세팅을 좀 만지다보니 또 세팅병이 도져서 터미널을 갈아엎었다고 볼 수 있을만큼 손을 많이 댔는데 이 과정에서 하루~이틀정도 삽질을 했던것같다.\n여러가지 플러그인과 세팅들이 있지만 가장 먼저 Tmux세팅부터 남긴다.\n\n## Tmux?\n\nTmux는 **Terminal multiplexer**의 일종인데 터미널 화면을 분할해서 사용할 수 있다.\n세션에서 서버를 실행중이라면 종료하지 않고 최소화와 같은 기능으로도 사용할 수 있지만 나는 화면분할 위주로 사용하고 있다.\n\n## 용어\n\n본격적인 사용에 앞서 사용과 설정에서의 이해를 위해 Tmux의 실행단위들을 알아보자\n\n### Pane\n\n**Pane**은 Tmux에서 가장 작은 실행단위로 Tmux에서 화면을 분할한다는 것은 이 Pane을 생성한다는 뜻이다.\n가로나 세로로 분할할 수 있고 특정 커맨드를 입력하면 Pane의 갯수에 맞춰 추천하는 화면 구성을 돌아가며 전환해준다.\n\n### Window\n\nPane이 한개 이상 모여 **Window**를 구성한다.\nWindow는 VSC나 브라우저의 탭으로 이해하면 되는데 동일한 화면에 나타나지는 않지만 실행중인 세션에서 옮겨가며 사용할 수 있다.\n\n### Session\n\nWindow가 하나 이상 모이면 **Session**이 구성된다.\n**Session**은 tmux에서 관리하는 가장 큰 실행단위로 tmux를 실행하면 가장 먼저 생성되는 요소이다.\nVSC에서의 창 하나로 이해하면 될 것 같다.\n`detach`로 작업을 유지한채 최소화 시키고 `attach`를 통해 다시 열 수 있다.\n\n## 설치\n\nUbuntu를 기준으로 설치는 아주 쉽다.\n\n```bash\nsudo apt install tmux\n```\n\n설치가 다 됐으면 `tmux`를 입력해 실행할 수 있다.\n\n## 설정\n\n아래는 내가 사용하고 있는 .tmux.conf이다.\nroot디렉토리(Ubuntu라면 `~/`)에 `.tmux.conf`파일을 만들어주면 된다.\n\n<details>\n<summary>.tmux.conf</summary>\n\n```conf\n# rmap prefix from 'C-b' to 'C-a'\nunbind C-b\nunbind C-Space\nset-option -g prefix C-a\nbind-key C-a send-prefix\n\n# split panes using | and -\nbind | split-window -h\nbind - split-window -v\nunbind '\"'\nunbind %\n\n# reload config file\nbind r source-file ~/.tmux.conf\\; display-message \"Config reloaded.\"\n\n# switch panes using Alt-arrow without prefix\nbind -n M-Left select-pane -L\nbind -n M-Right select-pane -R\nbind -n M-Up select-pane -U\nbind -n M-Down select-pane -D\n\n# vim setting\nis_vim=\"ps-o state= -o comm= -t '#{pane_tty}' \\\n    | grep -iqE '^[^TXZ ]+ +(\\\\S+\\\\/)?g?(view|n?vim?x?)(diff)?$'\"\n\nbind-key -n C-h  if-shell  \"$is_vim\"  \"send-keys C-h\"  \"select-pane -L\"\nbind-key -n C-j   if-shell  \"$is_vim\"  \"send-keys C-j\"   \"select-pane -D\"\nbind-key -n C-k  if-shell  \"$is_vim\"  \"send-keys C-k\"  \"select-pane -U\"\nbind-key -n C-l   if-shell  \"$is_vim\"  \"send-keys C-l\"   \"select-pane -R\"\nbind-key -n C-\\   if-shell  \"$is_vim\"  \"send-keys C-\\\\\"  \"select-pane -l\"\n\n# Enable mouse control (clickable windows, panes, resizable panes)\nset -g mouse on\n\n# don't rename windows automatically\nset-option -g allow-rename off\n\n# tmux\nset-option -sg escape-time 10\nset-option -g default-terminal 'tmux-256color'\nset-option -ga terminal-overrides ',*256col*:Tc'\nset-option -g focus-events on\n\n######################################\n###########Design change##############\n######################################\n\n## loud or quiet?\nset-option -g visual-activity off\nset-option -g visual-bell off\nset-option -g visual-silence off\nset-window-option -g monitor-activity on\nset-option -g bell-action none\n\n# modes\nsetw -g clock-mode-colour colour5\nsetw -g mode-style bold\nsetw -g mode-style fg=colour1\nsetw -g mode-style bg=colour18\n\n# panes\nset -g pane-border-style bg=colour0\nset -g pane-border-style fg=colour255\nset -g pane-active-border-style bg=colour242\nset -g pane-active-border-style fg=colour83\n\n# statusbar\nset -g status-position bottom\nset -g status-justify left\nset -g status-bg colour18\nset -g status-fg colour137\nset -g window-status-style dim\nset -g status-left \"#{?client_prefix,Ω,ω}\"\nset -g status-right \"#{cpu_bg_color} CPU: #{cpu_icon} #{cpu_percentage} | #[fg=colour233,bg=colour19,bold] %d/%m #[fg=colour233,bg=colour8,bold] %H:%M:%S \"\nset -g status-right-length 120\nset -g status-left-length 20\n\nsetw -g window-status-current-style fg=colour1\nsetw -g window-status-current-style bg=colour18\nsetw -g window-status-current-style bold\nsetw -g window-status-current-format ' #I#[fg=colour249]:#[fg=colour255]#W#[fg=colour248]#F '\nsetw -g window-status-style fg=colour9\nsetw -g window-status-style bg=colour18\nsetw -g window-status-style none\nsetw -g window-status-format ' #I#[fgcolour237]:#[fg=colour250]#W#[fg=colour244]#F 'e\n\n# List of plugins\nset -g @plugin 'tmux-plugins/tpm'\nset -g @plugin 'tmux-plugins/tmux-sensible'\nset -g @plugin 'tmux-plugins/tmux-cpu'\nset -g @plugin 'egel/tmux-gruvbox'\n\nset -g @tmux-gruvbox 'dark'\n\n# Initialize TMUX plugin manager (keep this line at the very bottom of tmux.conf)\nrun '~/.tmux/plugins/tpm/tpm'\n```\n\n</details>\n\n100줄 가까이 되는 길이라 줄였다. 순서대로 살펴보자면, 가장 먼저 `prefix`키를 기본 설정돼있는 `Ctrl`+`b`에서 `Ctrl`+`a`로 바꿔줬다.\n기본 `Ctrl`키 위치에서도 `b`보다 `a`가 누르기 편하기도 하고 나는 `Capslock`버튼과 `Ctrl`버튼을 바꿔줬기 때문에 바로 옆에 붙어있어서 더 편했다.\n그리고 수평분할을 `prefix`+`|`, 수직분할을 `prefix`+`-`로 바꿔줬다.\n\ntmux는 `truecolor`를 지원하는데 이것 때문에 계속 오류가 떠서 애를 좀 먹었다.\n중간에 _tmux_ 주석 처리 된 부분이 문제의 부분인데 여기저기 찾아보면서 만지작거리다가 이 설정으로 해결됐다.\n.zshrc에서 아래의 설정도 해 줘야한다.\n\n```zshrc\nexport TERM=tmux-256color\n```\n\n그 아래 디자인 부분은 tmux 상태바와 기타 다른부분들 디자인인데 잘 모르겠어서 다른 분의 configuration을 그대로 사용했다.\n상태바는 맨 아래 부분에서 볼 수 있듯 플러그인을 설치해서 사용중인데 플러그인별로 스타일을 설정하거나 고정돼있어서 딱히 필요없는 듯 하다.\ntmux 플러그인은 [깃허브](https://github.com/tmux-plugins/tpm)에서 플러그인 매니저를 설치한 후에 사용할 수 있다.\n\n처음 설정을 했다면 저장 후 tmux를 실행하던가 이미 실행중이라면 터미널에 아래 명령어를 입력해서 reload시켜주자.\n\n```bash\ntmux source ~/.tmux.conf\n```\n\n처음 `.tmux.conf`가 적용되고 나서 위 conf처럼 단축키를 지정해줬다면 `<prefix>`+`r`키를 이용해 간편하게 reloading할 수 있다.\n\n## 참고자료\n\n- <https://hbase.tistory.com/200>\n- <https://velog.io/@piopiop/Linux-tmux%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%B4%EB%B3%B4%EC%9E%90>\n- <https://velog.io/@ur-luella/tmux-%EC%82%AC%EC%9A%A9%EB%B2%95>\n- <https://data-newbie.tistory.com/226>\n- <https://www.hamvocke.com/blog/a-guide-to-customizing-your-tmux-conf/>\n"},{"excerpt":"블로그 방문 통계 분석 블로그를 이왕시작한거 방문수도 체크해보기로 했다.\n여기저기 기웃거리면서 따라해봤는데 github page 배포 딜레이때문인지 측정이 안돼서 당황했다.\n이것저것 만지다보니 되긴 했는데 정확히 어떤부분인지는 모르겠다.\n일단 현재 상태 기준으로 작성하기로 했다.(2022.06.09 기준) 1. Google Aanlytics 설정 먼저 G…","fields":{"slug":"/gatsby-analytics/"},"frontmatter":{"date":"June 09, 2022","title":"[Gatsby]블로그에 Google Analytics 연결","tags":["Gatsby","blog","google analytics"]},"rawMarkdownBody":"\n## 블로그 방문 통계 분석\n\n블로그를 이왕시작한거 방문수도 체크해보기로 했다.\n여기저기 기웃거리면서 따라해봤는데 github page 배포 딜레이때문인지 측정이 안돼서 당황했다.\n이것저것 만지다보니 되긴 했는데 정확히 어떤부분인지는 모르겠다.\n일단 현재 상태 기준으로 작성하기로 했다.(2022.06.09 기준)\n\n## 1. **Google Aanlytics** 설정\n\n먼저 [**Google Analytics** 홈페이지](http://analytics.google.com/)에 들어가 계정을 만들고 속성을 설정해준다.\n\n![계정 생성](1.JPG)\n\n계정 이름을 입력하고 계정 데이터 공유 설정을 해준다.\n처음부터 Google제품 및 서비스를 제외한 나머지 3항목이 체크되어있다.\n나는 계정 이름은 grasshopper42, 체크박스는 처음 그대로 진행했다.\n\n![속성 설정](2.JPG)\n계정을 만들고 다음을 누르면 이제 데이터 측정을 위한 속성설정을 해야한다.\n개발블로그 추적을 위한 속성이기 때문에 속성 이름은 dev blog로 했다.\n시간대와 통화는 기본으로 미국과 달러로 기본설정되어있기 때문에 각각 대한민국과 원으로 바꿔준다.\n\n![비즈니스 정보](3.JPG)\n비즈니스 정보는 그렇게 중요할것같지 않아서 대충 설정했다.\n\n![플랫폼 선택](4.JPG)\n이제 플랫폼을 선택해야하는데 블로그를 추적할 계획이니까 **웹**을 선택한다.\n\n![데이터 스트림 설정](5.JPG)\n데이터를 스트리밍할 블로그 정보를 입력해준다.\n나는 grasshopper42.github.io/ 와 Dev blog라고 입력했다.\n아래 향상된 측정 부분에 측정할 데이터를 선택할 수 있는데 기본 그대로 뒀다.\n\n여기까지 설정을 마쳤으면 웹 스트림 세부정보라는 창이 뜨면서 **측정ID**값을 얻을 수 있다.\n\n## 2. gatsby-plugin-gtag\n\n이제 블로그와 **Google Analytics**를 연결해주기 위해 **Gatsby**에 **plugin**을 설치해준다\n\n```bash\nnpm install gatsby-plugin-gtag\n```\n\n플러그인 설치가 완료되었으면 프로젝트 루트 폴더의 `gatsby-config.js`를 열어서 `plugin`을 추가해준다.\n\n```js\n// ~/gatsby-config.js\n\n// ...\nmodule.exports = {\n  // ...other options\n  plugins: [\n    {\n      resolve: `gatsby-plugin-gtag`,\n      options: {\n        // Google Analytics에서 얻은 측정ID를 입력\n        trackingId: `측정ID`,\n        // gtag tracking script를 배포될 html의 head에 넣을지 선택\n        head: true,\n        // IP 익명화 선택\n        anonymize: true,\n      },\n    },\n    // ...other plugins\n  ],\n}\n```\n\n이제 블로그를 다시 배포하고 블로그에 방문한 다음 Google Analytics 대쉬보드를 보면 사용자 1이 증가하는 모습을 볼 수 있다.\n`head`를 `true`로 설정했다면 블로그에서 개발자도구를 열어 `<head>`에 다음과 같은 코드가 있는지 보면 제대로 입력이 됐는지 알 수 있다.\n\n```html\n<script async src=\"https://www.googletagmanager.com/gtag/js?id=측정ID\"></script>\n<script>\n  //... trackingId, options\n</script>\n```\n\n## 참고자료\n\n- <https://www.gatsbyjs.com/plugins/gatsby-plugin-gtag/#gatsby-plugin-gtag>\n- <https://inasie.github.io/it%EC%9D%BC%EB%B0%98/1/>\n- <https://janeljs.github.io/blog/google-analytics/>\n- <https://devfoxstar.github.io/web/gatsby-ga-tracking/>\n- <https://blog-lino.dev/trouble-shooting/ga4-issues/>\n"},{"excerpt":"NestJS + Prisma 처음 백엔드를 구축할때 Apollo + GraphQL을 사용하기로 하면서 쓰기 시작한 Prisma를 NestJS + RestAPI로 migration하면서 NestJS와 많이 쓰는 TypeORM보다 익숙하고 편리해서 가져왔는데 막상 쓰려니 부족한 자료에 지금이라도 TypeORM으로 넘어가야하나 하는 고민을 수없이 했다.\n가장 …","fields":{"slug":"/nestjs-prisma-dbhandling/"},"frontmatter":{"date":"June 08, 2022","title":"[NestJS]NestJS에서 Prisma 사용하기","tags":["NestJS","Prisma","MongoDB","Jest"]},"rawMarkdownBody":"\n## NestJS + Prisma\n\n처음 백엔드를 구축할때 **Apollo + GraphQL**을 사용하기로 하면서 쓰기 시작한 **Prisma**를 **NestJS + RestAPI**로 migration하면서 **NestJS**와 많이 쓰는 **TypeORM**보다 익숙하고 편리해서 가져왔는데 막상 쓰려니 부족한 자료에 지금이라도 **TypeORM**으로 넘어가야하나 하는 고민을 수없이 했다.\n가장 큰 문제는 **OOP**환경에 대한 **Prisma**의 문서부족이었다.\n기본적인 세팅에 대한 부분은 **Prisma**와 **NestJS**공식문서에 잘 나와있었지만 조금만 깊어지면 문서가 영문으로조차 없어서 며칠동안 삽질을 했다.\n대체적으로 **OOP**와 **테스트**에 대한 내 이해부족때문이었다.\nNestJS시작부터 글을 적을 생각이었지만 기억이 날아갈까봐 우선 Prisma적용에 대한 글부터 남긴다.\n\n> 여러모로 부족해 설명에 오류나 누락이 있을 수 있습니다. 혹시나 이 글을 보신다면 많은 피드백 부탁드립니다.\n\n### 1. NestJS에 PrismaClient 생성\n\n1. 우선 **NestJS**와 **Prisma** 기본세팅이 돼있다는걸 가정하고 바로 **PrismaClient**생성으로 넘어간다. `nest-cli`를 이용해 `prisma`모듈과 서비스를 생성해준다.\n\n   ```bash\n   nest g mo prisma && nest g s prisma\n   ```\n\n2. `prisma.service.ts`에서 아래의 코드를 입력한다.\n\n   ```typescript\n   // ~/src/prisma/prisma.service.ts\n   import { INestApplication, Injectable, OnModuleInit } from \"@nestjs/common\"\n   import { PrismaClient } from \"../../prisma/generated\" //보통은 @prisma/client에서 불러오지만 yarn berry를 써서 따로 생성된 디렉토리에서 불러왔다.\n\n   @Injectable()\n   export class PrismaService extends PrismaClient implements OnModuleInit {\n     async onModuleInit() {\n       await this.$connect()\n     }\n\n     async enableShutdownHook(app: INestApplication) {\n       this.$on(\"beforeExit\", async () => {\n         await app.close()\n       })\n     }\n   }\n   ```\n\n   여기서부터 당황스러웠다. 지금까지 프리즈마 클라이언트를 생성하면 `const prisma = new PrismaClient()`같은 방법을 썼는데 서비스를 `PrismaClient`에서 `extends`하고 이걸 `onModuleInit`에 `implement`를 한다._[extends? implement?](https://www.howdy-mj.me/typescript/extends-and-implements/)_ [공식문서](https://docs.nestjs.com/recipes/prisma)에 이유가 상세히 잘 나와있지만 간단하게 설명하자면 **Prisma**를 **DB**에 빠르게 연결하기 위해 `onModuleInit`을 사용한다. 선택사항이지만 사용하지 않을경우 **Prisma**는 첫 호출이 있기 전까지 **DB**에 연결하지 않는다. `enableShutdownHooks`는 [공식문서](https://docs.nestjs.com/recipes/prisma#issues-with-enableshutdownhooks)와 [이 포스트](https://progressivecoder.com/build-a-nestjs-prisma-rest-api/)를 보면 **Prisma**와 **NestJS**가 종료메서드에 상호간섭하기 때문에 서비스에서 함수를 생성하고 `main.ts`에서 호출해서 종료를 강제해주는 것 같다.(이부분은 완벽하게 이해를 못했다.)\n\n   <details>\n   <summary>main.ts</summary>\n\n   ```typescript\n   // ~/src/main.ts\n\n   import { NestFactory } from \"@nestjs/core\"\n   import { AppModule } from \"./app.module\"\n   import { PrismaService } from \"./prisma/prisma.service\"\n\n   async function bootstrap() {\n     const app = await NestFactory.create(AppModule)\n     const prisma: PrismaService = app.get(PrismaService)\n     prisma.enableShutdownHooks(app)\n     await app.listen(3000)\n   }\n   bootstrap()\n   ```\n\n   </details>\n\n3. `prisma.module.ts`에서 `Global`로 `export`해서 어느 모듈에서나 `provider`추가 없이 `injection`이 가능하도록 해준다.\n\n   ```typescript\n   // ~/src/prisma/primsa.module.ts\n\n   import { Global, Module } from \"@nestjs/common\"\n   import { PrismaService } from \"./prisma.service\"\n\n   @Global()\n   @Module({\n     providers: [PrismaService],\n     exports: [PrismaService],\n   })\n   export class PrismaModule {}\n   ```\n\n4. 이제 설정이 끝났고 다른 서비스에서 `constructor`에 `PrismaService`를 불러와 사용하면 된다.\n\n   ```typescript\n   // ~/src/post/post.service.ts\n\n   import { Injectable } from \"@nest/common\"\n   import { Post } from \"prisma/generated\"\n   import { PrismaService } from \"src/prisma/prisma.service\"\n   //...\n\n   @Injectable()\n   export class PostService {\n     constructor(private prisma: PrismaService) {}\n\n     // ...\n\n     async findOne(id: string): Promise<Post | null> {\n       return this.prisma.post.findUnique({\n         where: { id },\n       })\n     }\n\n     // ...\n   }\n   ```\n\n### 2. 테스트?\n\n**GraphQL**을 버리고 처음 **NextJS**에서 기본 API routing으로 백엔드 기능을 구현했을때는 빠르게 최소한의 기능만 구축하기 위해서 테스트를 전혀 안하다가 **NestJS**로 넘어오면서 **TDD**를 해봐야겠다는 욕심(?)이 생겼다.\n테스트는 기본 설정돼있는 **Jest**로 하려했는데 nomadcoder에서 NestJS + Jest 기본 강의만 듣고 시작한 나에게 **TDD**는 너무 큰 산이었다.\n아직 간단한 CRUD밖에 없기때문에 테스트코드야 어떻게 짠다지만 **DB**와 **ORM**은 어떻게 해야하는지 전혀 감이 오지 않았다.\n당장에 **Jest**자체도 낯설었다.\n구글을 뒤져 **NestJS**와 **Prisma**를 사용해 테스트하는 예제 몇개를 구할 수 있었지만 대부분 **Prisma**를 `mocking`해서 테스트하는 방식이었다.\n하지만 **Prisma**자체가 제대로 돌아갈지도 미지수인 상황에서 `mocking`만 해봤자 무슨의미인가 싶고 **TDD**를 도입하는 만큼 수동테스트를 최대한 줄이고싶었다.\n문제는 현재 개발용 DB에 테스트용 더미데이터를 넣어뒀는데 계속 불필요한 테스트코드가 쌓이는것도 싫고, 만약 서비스를 배포한 후에도 같은 **DB**에 연결되면 심각한 문제를 초래하기 때문에 별도의 테스트용 DB에 연결할 필요가 있었다.\n지금까지는 다른 DB에 연결할 필요가 없었기 때문에 방법을 전혀 모르는 상태였다.\n여러모로 방법을 찾아봤는데 처음 생각한 방안은 **PrismaClient**를 **서비스 DB**와 **Test DB**에 각각 연결되도록 `generate`를 두번 하는 방법이었다.\n하지만 방법도 복잡하고 **Prisma Engine**이나 `generate`에 대한 이해가 부족해서 맞는 방법인지 확신이 없었다.\n\n### 3. Prisma ↔ Test용 DB 연결\n\n한참 공식문서를 뒤지다가 단서를 얻었다. **PrismaClient**를 생성할 때 `datasource`를 `overriding`하는 방법이었다.\n\n문제는 다시 **OOP**로 돌아온다. **FP**에서는\n\n```typescript\nconst prisma = new PrismaClient({\n  datasource: {\n    db: { url: DatabaseUrl },\n  },\n})\n```\n\n처럼 간단하게 `datasource overriding`을 할 수 있는데 **NestJS**같은 **Class**에서는 어떻게 해야할지 모르겠는데 자료도 없어 막막했다.\n나오지도 않는 구글을 한참 뒤지다가, **Prisma**랑 **PrismaClient**라이브러리 소스를 한참뒤지다가 겨우 단서를 찾았다.\n`constructor`에 `super`로 선언해주면 되는 간단한 문제였다.\n\n> <details>\n> <summary>코드</summary>\n>\n> ```typescript\n> // ~/src/prisma/prisma.service.ts\n>\n> // import ...\n>\n> @Injectable()\n> export class PrismaService extends PrismaClient implements onModuleInit {\n>   constructor() {\n>     const url =\n>       process.env.NODE_ENV === \"test\"\n>         ? process.env.TEST_DATABASE_URL\n>         : process.env.DATABASE_URL\n>     super({\n>       datasources: {\n>         db: {\n>           url,\n>         },\n>       },\n>     })\n>   }\n> }\n>\n> // async onModuleInit...\n> ```\n>\n> </details>\n\n방법은 찾았는데 DB URL을 어떻게 입력할지를 놓고 또 한참 씨름했다.\n`.env`에 넣고 `NODE_ENV`에 따라 각각 다른 주소가 들어가도록 하는데 `@nestjs/config`를 쓰니 문제가 발생했다.\n`.env`와 `.env.development`, `.env.test`에 모두 `DATABASE_URL`이라는 같은 환경변수로 설정하고 돌렸더니 주구장창 `.env`에 있는 주소만 입력돼서 난감했다.\n`.env`는 `DATABASE_URL`로 유지하고 개발과 테스트 환경변수를 다른 이름으로 지정했더니 제대로 불러오는데 서버를 직접 돌릴때는 `NODE_ENV`를 바꿔가며 돌려봐도 문제없이 잘 돌아가는데 `jest`로 테스트만 돌리면 `config`가 환경변수를 불러오지 못했다.\n한참씨름하다가 그냥 `.env`에 `TEST_DATABASE_URL`로 Test DB 이름을 설정하고 `process.env`로 불러오는 방법을 택했다. 잘 돌아간다.\n\n### 결과\n\n이것저것 붙잡고 한참 씨름한 덕분에 `constructor`와 `super`에 대한 이해도와 `@nestjs/config`사용, 환경변수 적용이 익숙해졌다.\n뜯어보면 별거 아니지만 누군가는 나와 같은 문제를 겪을 수도 있을 것 같아 문제 해결하고 잊어버리기 전에 급하게 적었다.\n테스트도 결국 비용이고 대부분의 테스트코드가 `mocking`으로 적히는 걸로 보아 그게 효율적인 방법일 것 같아서 어느정도 DB에 직접 연결해서 테스트를 하다가 규모가 커지면 `mocking`해서 테스트 하는 방법으로 전환해야겠다.\n\n### 참고자료\n\n- [NestJS 공식문서](https://docs.nestjs.com/recipes/prisma)\n- [Prisma 공식문서](https://www.prisma.io/docs/reference/api-reference/prisma-client-reference#datasources)\n- <https://progressivecoder.com/build-a-nestjs-prisma-rest-api/>\n- <https://blog.logrocket.com/how-to-use-nestjs-prisma/>\n"},{"excerpt":"Gatsby? 22년 새해를 맞아 만들었던 Jekyll블로그를 버리고 Gatsby로 블로그를 옮겼다. 공부한 것들을 글로 남기자 다짐했지만 글로 정리한다는건 귀찮은 일이고 더군다나 익숙치도 않은 마크다운문법을 쓰려니 손에 잡히지가 않았다. 귀찮은 일이었지만 Gatsby로 옮긴건 그나마 React가 익숙한 까닭이다. 지금 서비스에 사용중인 NextJS를 쓸…","fields":{"slug":"/hello-world/"},"frontmatter":{"date":"June 03, 2022","title":"Hello World!","tags":["hello","world"]},"rawMarkdownBody":"\n## Gatsby?\n\n22년 새해를 맞아 만들었던 Jekyll블로그를 버리고 Gatsby로 블로그를 옮겼다. 공부한 것들을 글로 남기자 다짐했지만 글로 정리한다는건 귀찮은 일이고 더군다나 익숙치도 않은 마크다운문법을 쓰려니 손에 잡히지가 않았다. 귀찮은 일이었지만 Gatsby로 옮긴건 그나마 React가 익숙한 까닭이다. 지금 서비스에 사용중인 NextJS를 쓸까도 생각해봤지만 직접 디자인하고 구현하려니 시간이 부족하고 template도 부족해 급한대로 Gatsby로 옮겼다.\n\n## 다시 블로그를 잡은건\n\n멀쩡한 Jekyll 블로그는 지금까지 쓰지도 않다가 굳이 Gatsby로 옮겨가며 글을 쓰는것은 슬슬 정리해두지 않고는 기억할 자신이 없어졌기 때문이다. unhide 서비스를 개발하며 혼자 풀스택으로 여러 프레임워크와 라이브러리를 급하게 공부해가며 쓰다보니 점점 헷갈리기 시작한다. 지금까지 써왔던 GraphQL을 버리고 NestJS로 옮겨가는 과정에서 내가 계속 들어다 볼 요량도 있지만 팀에 합류할 개발자를 위해서도 정리를 좀 해두려한다. NestJS 뿐만 아니라 언어나 다른 프레임워크 관련해서도 간단하게나마 조금씩 써둬야겠다.\n"}]}},"pageContext":{}},"staticQueryHashes":[]}